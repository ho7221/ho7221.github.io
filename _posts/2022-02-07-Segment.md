# 세그먼트
## 세그먼트란?
![Unear Address](https://user-images.githubusercontent.com/45323902/152786294-3be98e9f-4c7d-4621-beae-dcd07f6bb89f.png)  
IA-32에서 메모리 관리를 segmentation & paging 두 부분으로 나눈다. CPU는 논리주소를 생성하고 세그먼테이션 장치에 전달한다. 세그먼테이션 장치는 페이징 장치로 선형주소를 전달하고 페이징 장치는 물리메모리의 주소를 계산하는 방식으로 이루어진다. 논리주소가 선형주소로 변형되는 과정만 보면 논리주소는 (selector, offset) 쌍으로 구성되었는데 세그먼트의 기본주소(segment descripter)에서 offset을 더해서 선형주소를 계산하고 페이징 장치로 넘긴다.  물리 메모리 공간을 용도에 따라 여러 부분으로 나눈다. Stack, Data, Code Segment로 나누는데, 이를 가르키는 pointer를 segment register라고 한다. segment와 segment register는 다르다!  
![Segment Registers](https://user-images.githubusercontent.com/45323902/152742924-f9b9136c-ea42-4e4d-b7d6-01d90f33ffff.png)   
### 1. Code Segment
Code Segment는 메모리에서 명령어가 저장된 부분이다. 그래서 프로세서는 명령어를 CS register와 EIP를 통해 실제 메모리 주소에서 불러온다. 참고로 이때 EIP는 CS와 다음 명령어의 주소간의 offset을 가지고 있다. 또한 CS register는 application program이 불러오는 것이 아닌 명령어나 내부 프로세서의 작업(procedure call, interrupt handling, task switching)으로 불러온다.
### 2. Data Segment
DS, ES, FS, GS register는 모두 Data Segment를 가리킨다. DS가 네개나 있는 이유는 자료구조를 효율적이고 안전하게 관리하기 위함이다. 예를 들어 DS reg는 현재모듈의 자료구조, ES reg는 상위모듈에서 들어오는 데이터, FS는 유동적으로 사용, GS는 다른 프로그램과 공유하는 용도 처럼 필요에 따라 다르게 DS를 사용할 수 있다.
### 3. Stack Segment 

